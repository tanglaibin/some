sql:


数据库插入防止重复值：
declare
  jilu_guid number;
begin
  select count(*)
    into jilu_guid
    from tlb t
   where pdu = 'DC'
     and version = 'R19'
     and subsys = 'huawei'
     and feature = 'a'
     and xpath = 'b4'
     and type is null  //不能写 type = ''
     and operation is null
     and delflag = 0
     and source = 'api';
  if jilu_guid = 0 then
    insert into tlb
      (pdu,
       version,
       subsys,
       feature,
       xpath,
       type,
       operation,
       delflag,
       source)
    values
      ('DC', 'R19', 'huawei', 'a', 'b4', '', '', 0, 'api');
  end if;
end;



1,更新字段值  批量更新
update r_problem set workStatus =1 where workStatus = 4
UPDATE dir_module SET NAME ='L3_IPv4', description ='L3_IPv4' WHERE id = 375;UPDATE dir_module SET NAME ='L3_IPv4',description ='L3_IPv4' WHERE id = 376;UPDATE dir_module SET NAME ='L3_IPv4',description ='L3_IPv4' WHERE id = 443;UPDATE dir_module SET NAME ='L3_IPv4',description ='L3_IPv4' WHERE id = 947;

2,选择
select * from r_problem where workStatus !=2 and workStatus !=5
SELECT * FROM r_problem WHERE developer ='w00215231' and probdes like '%配置assi%'

3,把null值改为0或""
SELECT IFNULL(filep,'') AS filep FROM r_operate

4,两个表联合查数据，主表某id对应二表id，得到该id对应的具体name。									
select d.*,l.L_NAME from T_TOOLS_EYC_TYPE_DETAIL_CN d,T_TOOLS_EYC_TYPE_LINECARD_CN l where d.L_ID=l.L_ID  and D_DELETE=1 and S_ID=1 order by D_ID

5,两个表联合查数据，自定义取得哪些字段。
select s.S_ID,s.S_NAME,t.T_NAME from T_TOOLS_EYC_TYPE_STENCIL_CN s,T_TOOLS_EYC_TYPE_CN t where s.S_DELETE=1 and s.T_ID=t.T_ID order by t.T_ID,s.S_ID

6,多表查询，并将一多表查询结果做为字段。
select e.*,t.T_NAME from t_TOOLS_eyc_type_cn t,
	(select d.*,s.T_ID,s.S_NAME,l.L_NAME from 
	t_TOOLS_eyc_type_detail_cn d,t_TOOLS_eyc_type_stencil_cn s, t_TOOLS_eyc_type_linecard_cn l
   where s.S_ID=d.S_ID and D_ID=163)e
  where t.T_ID=e.T_ID

7,mybatis 更新数据库
update T_TOOLS_EYC_TYPE_DETAIL_CN 
  		set 
  		S_ID=#{sId,jdbcType=DECIMAL},
  		L_ID=#{lId,jdbcType=DECIMAL},
  		D_PPNAME=#{dPpname,jdbcType=VARCHAR},
  		D_ONE=#{dOne,jdbcType=DECIMAL},
  		D_TWO=#{dTwo,jdbcType=DECIMAL},
  		D_THREE=#{dThree,jdbcType=DECIMAL},
  		D_FOUR=#{dFour,jdbcType=DECIMAL},
  		D_FIVE=#{dFive,jdbcType=DECIMAL},
  		D_SIX=#{dSix,jdbcType=DECIMAL},
  		D_DELETE=#{dDelete,jdbcType=VARCHAR}
  		where D_ID=#{dId,jdbcType=DECIMAL}

8，多表联查 left join  *
select A.*,B.priority as version_priority,B.patchQuestiontester as patchQuestiontester,B.verid as versionid, B.schemeReviewStatu as schemeReviewStatu, B.verPatchType as verPatchType, B.deliverPerson as deliverPerson, D.name as vname, C.name as sname, E.patchversion, B.question, B.iterativeStage, B.remark as conclusion, B.isputin as isputinVersion, dep.name as depName ,B.isRisk as isRisk, B.judgeConclusion as judgeConclusion, B.clarifyConclusion as clarifyConclusion, B.seReviewComment as seReviewComment 
from patchrequirement A  left join patchrequirement_version B on A.id=B.reqid 
left join 
patchrequirement_version_status C on B.status=C.id left join 
dir_version D on B.verid=D.id left join patch E on B.patchid=E.id left join dir_department dep on dep.id = A.department  
where 1=1 and A.requirementVersionSrc = 0  and 
B.patchid = '784' 
order by A.product,A.patch, A.id, B.verid



9，group by 多个字段  left join结果集
数据是以基线表left join匹配表得出的  基线表中 基线匹配到一次，连同匹配表中数据，列出来一次，但是基线数据是一样的，因为是相同的基线；只需要根据需要的数据，group一次即可，得到匹配次数。

按照guid分组后，结果集表中，每条基线，除了匹配表中后面的数据被合并，原来的数据都一样。
对需要取值的字段，采用聚合函数：SUM(m.mTime
其他原来的基线数据，直接max封装取出来。因为值只有一个。
				select nvl(SUM(m.mTime), 0) times,
                    max(a.enname) enname,
                    max(a.cnname) cnname,
					max(a.node_oid) node_oid,
					max(a.guid) guid,
					max(a.module) module,
					max(a.node_name) node_name,
					max(a.max_access) max_access
                            from t_ens_mib_base a
                            LEFT JOIN t_ens_mib_match m
                            ON (m.fk_mib = a.guid)
		                    where 1=1 and a.pdu='LSW'
                            and a.module='ENTITY-MIB'
                            group by a.guid
										 


下面的方式结果一样，但是过多的group没啥意义，因为字段里值都一样。
							select nvl(SUM(m.mTime), 0) times,
							a.enname,
							NVL(TO_CHAR(a.cnname), '—') cnname,
							a.node_oid,
							a.guid,
							max(a.module) module,
							a.node_name,
							a.max_access 
                              from t_ens_mib_base a
                                 LEFT JOIN t_ens_mib_match m
                                  ON (m.fk_mib = a.guid)
		                          where 1=1 and a.pdu='LSW'
                              and a.module='ENTITY-MIB'
                              group by a.guid, 
											a.module, 
											a.enname,
											a.cnname, 
											a.node_oid, 
											a.node_name,
											a.max_access








