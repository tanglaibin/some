
一，strust2中 action设置cookie  保存用户账户密码信息【action中】
// 如果选择保存cookie一周则保存一周
cookie.addCookie(this.getResponse(),"userPassword",users.getUserPassword(),7 * 24 * 60 * 60);
cookie.addCookie(this.getResponse(), "userName", users.getUserName(), 7 * 24 * 60 * 60);
// 如果选择保存cookie一个月则保存一个月
cookie.addCookie(this.getResponse(),"userPassword",users.getUserPassword(),30 * 24 * 60 * 60);
cookie.addCookie(this.getResponse(), "userName", users.getUserName(), 30 * 24 * 60 * 60);
// 如果选择保存cookie一年则保存一年
cookie.addCookie(this.getResponse(),"userPassword",users.getUserPassword(),365 * 24 * 60 * 60);
cookie.addCookie(this.getResponse(), "userName", users.getUserName(), 365 * 24 * 60 * 60);
// 如果选择保存cookie一天则保存一天
cookie.addCookie(this.getResponse(), "userPassword", users.getUserPassword(), 24 * 60 * 60);
cookie.addCookie(this.getResponse(), "userName", users.getUserName(), 24 * 60 * 60);

cookie方法：
1，添加cookie
public static void addCookie(HttpServletResponse response, String name, String value, int maxAge)
    {
        Cookie cookie = new Cookie(name, value);
        cookie.setPath("/");
        if (maxAge > 0)
            cookie.setMaxAge(maxAge);
        response.addCookie(cookie);
    }
2，获取cookie
public static String getCookieByName(HttpServletRequest request, String name)
    {
        Map<String, Cookie> cookieMap = cookie.readCookieMap(request);
        if (cookieMap.containsKey(name))
        {
            Cookie cookie = (Cookie) cookieMap.get(name);
            return cookie.getValue();
        }
        else
        {
            return null;
        }
    }
protected static Map<String, Cookie> readCookieMap(HttpServletRequest request)
    {
        Map<String, Cookie> cookieMap = new HashMap<String, Cookie>();
        Cookie[] cookies = request.getCookies();
        if (null != cookies)
        {
            for (int i = 0; i < cookies.length; i++)
            {
                cookieMap.put(cookies[i].getName(), cookies[i]);
            }
        }
        return cookieMap;
    }


二，设置session域值【action中】
this.getRequest().getSession().setAttribute("employeeId", users.getEmployeeId());

三，jsp页面写java代码得到值  后面用值
<%@ page language="java" pageEncoding="GBK"%>
<%@ taglib prefix="s" uri="/struts-tags"%>
<%
	// 读取返回的错误信息
	String message = (String) request.getAttribute("message");
	if(message == null){
		message = "";
	}
	// 取得用户工号
	String loginUserName = (String) request.getSession().getAttribute("loginUserName");
%>
<html>

用值——
<%=message%>


四，页面加载完  指定方法 
<body class="" onload="init()">

五，校验用户名是否为空
if(trim(userName) == ""){
	alert("用户名不能为空！");
	document.getElementById("userName").focus();
	return false;
}


六，只能为英文数字校验
只能为英数字
function chkEisu(objVal){
    var checkVal = objVal;
	if (checkVal == undefined || checkVal == ""){
	    return true;
	}
	var i;
	var c;
	for(i = 0; i < checkVal.length; i++){
		c = checkVal.charCodeAt(i);
		if (( c >= 0x0030 && c <= 0x0039 ) || ( c >= 0x0041 && c <= 0x005a ) || ( c >= 0x0061 && c <= 0x007a )){
		}else{
            return false;
		}
	}
    return true;
}

七，特殊字符排查校验，例如："'"
function special_Chk(){
	var str = $('#chexk').val();
	var hanTxt="'";
	var chkRst = "true";
	var c = "";
	for(i = 0; i < str.length; i++){
		c = str.charAt(i);
		if(hanTxt.indexOf(c) != -1 ){
			chkRst = "false";
			break;
		}
	}
	return chkRst;
}



八,jsp struts2 S标签
引入S标签：<%@ taglib prefix="s" uri="/struts-tags"%>
创建form表单：<s:form action="/loginaction/login" method="post">
遍历1：iterator
<s:iterator value="xxxList">
	<tr>
		<td>
	<span><s:property value="versionName" /></span>
		</td>
		<td>
	<span><s:property value="toBeRuledNum" /></span>
		</td>
		<td>
	<span><s:property value="toBePlanedNum" /></span>
		</td>
		<td>
	<span><s:property value="planedNum" /></span>
		</td>
		<td>
	<span><s:property value="releasedNum" /></span>
		</td>
	</tr>
</s:iterator>
遍历2：遍历list  根据序号奇偶  分别处理
<s:iterator value="xxxList" id="dir" status="stu" var="req">
<s:if test="#stu.odd">
。。。。
</s:if>
赋值：
<s:set var="patchMaker" value="#req.deliverPerson" />
<s:set var="verId" value="#req.verId" />
日期：<s:date name="lastLogin" format="HH:mm:ss"/>
文本输入框：<s:textfield id="xx" name="userVo.userName" size="18" maxlength="10" onkeydown="if(event.keyCode == 13){xxx()}" cssStyle="height:20;width:135"/>
密码输入框：<s:password id="xxx" name="userVo.userPassword" size="18" maxlength="18" onkeydown="if(event.keyCode == 13){xxx()}" cssStyle="height:20;width:135"/>
下拉选框：<s:select id="xxx" name="userVo.savetoday" headerValue="保存一天" headerKey="1" list="#{'2':'保存一周','3':'保存一月','4':'保存一年'}" onkeydown="if(event.keyCode == 13){xxx()}"></s:select>
if  else判断:
1，set设值  根据值ifelse
<s:set name="type" value="type"></s:set>
<s:if test="#type == 0">																
	<a href="###" class="xxx" onclick="linkLink('<s:property value="url"/>')">·<s:property value="name"/></a>				                								
</s:if>
<s:else>																
	<a href="###" class="xxx" onclick="linkLink('<%=request.getContextPath()%>/linkDir/<s:property value="url"/>')">·<s:property value="name"/></a>				                								
</s:else>
2，取值判断 设置ifelse
 <s:if test="#req.xxx != null && #req.xxx != ''">//xxx  xxx2为遍历的对象req的一个属性值
 <td id="aaa" class="bbb" ondblclick="fff('<s:property value="id"/>','<s:property value="verId"/>')"><s:property value="xxx"/></td>
 </s:if>
 <s:else>
 <td id="aaa" class="bbb" ondblclick="fff('<s:property value="id"/>','<s:property value="verId"/>')"><s:property value="xxx2"/></td>
 </s:else>

隐藏域：<s:hidden id="xxx" name="xxx"></s:hidden>


九,input等元素enter键按下去执行方法()
onkeydown="if(event.keyCode == 13){xxx()}"


十,注册方法 打开新窗口
function regist(){
	var url = "<%=request.getContextPath()%>/xxx/xxx.action";
	var params = "height=360, width=600,top=300, left=300, resizable=1,toolbar=no, menubar=no, scrollbars=no, resizable=no,location=no, status=no";
	var qmax_window = window.open(url, "", params);
}


十一，js  取得form  并指定action
document.forms[0].action = "<%=request.getContextPath()%>/xxx/xxx.action";
document.forms[0].submit();


十二,刷新页面 转发至新页面  
<META HTTP-EQUIV="Refresh" CONTENT="20;URL=dd.html">    
<META HTTP-EQUIV="Refresh" CONTENT="0;URL=/vrplmt/loginaction/init.action">
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
	    <META HTTP-EQUIV="Refresh" CONTENT="20;URL=dd.html">
	</head>
	<body>
		<p>Loading ...</p>
	</body>
</html>


jsp页面：
<% response.sendRedirect("security/vlogin.action"); %>


十三,DWR框架技术  用于js中直接调用java函数
配置：
1，jar包：dwr-3.0.jar

2，web.xml：
<servlet>
	<servlet-name>dwr-invoker</servlet-name>
	<servlet-class>org.directwebremoting.servlet.DwrServlet</servlet-class>
	<init-param>
		<param-name>debug</param-name>
		<param-value>true</param-value>
	</init-param>
	<init-param>
		<param-name>crossDomainSessionSecurity</param-name>
		<param-value>false</param-value>
	</init-param>
	<init-param>
		<param-name>allowScriptTagRemoting</param-name>
		<param-value>true</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>dwr-invoker</servlet-name>
	<url-pattern>/dwr/*</url-pattern>
</servlet-mapping>

3，dwr.xml  【放在WEB-INF目录下】
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dwr PUBLIC "-//GetAhead Limited//DTD Direct Web Remoting 3.0//EN" "http://getahead.org/dwr//dwr30.dtd">

<dwr>
	<allow>
		<create javascript="Demo" creator="new">
			<param name="class" value="test.dwr.Demo"></param>
		</create>
	</allow>
</dwr>

4，java类
package test.dwr;

public class Demo {
	public String test(String a){
		return a+"哈哈哈哈";
	}
}

5，jsp引用
<script type="text/javascript" src="dwr/engine.js"></script><%--固定写法--%>
<script type="text/javascript" src="dwr/util.js"></script><%--固定写法--%>
<script type="text/javascript" src="dwr/interface/Demo.js"></script><%--由框架自动生成,文件名根据DWR文件而来--%>

<body onload="validate()">

function validate() {
		Demo.test("dddd",callBack);
	}
	function callBack(data) {
		alert(data);
	}

十四，frameset 用于构建后台管理页面
<html>
<head>
<!-- 消除缓存 -->
<meta http-equiv="Expires" content="0" />
<meta http-equiv="Cache-Control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<title>xxx</title>
</head>
<frameset id="allFrame" name="allFrame" rows="150,*" cols="*"
	frameborder="no" border="0" framespacing="0" noresize>

	<frame src="<%=request.getContextPath() %>/top.jsp"
		name="topFrame" scrolling="auto" noresize="noresize" id="topFrame"
		title="topFrame" noresize />

	<frameset name="bottomFrame" rows="*" cols="410,*" framespacing="0"
		border="0" noresize>

		<frame src="<%=request.getContextPath() %>/left.jsp"
			name="leftFrame" id="leftFrame" scrolling="auto" noresize />

		<frame
			src="<%=request.getContextPath() %>/right.jsp"
			name="rightFrame" id="rightFrame" scrolling="auto" noresize />

	</frameset>
</frameset>
</html>

window.parent.frames["rightFrame"].location = "<%=request.getContextPath()%>/page/message/searchReceiveMessage.action?menuid=0";



十五，双击表格td  编辑td中的值  输入新值  保存
双击方法：ondblclick="editPatchQuestiontesterStage()
双击后，td显示为待编辑状态：--获取该td表格对象  保存之前td值  向该td输入新的值
function fff(id,verId){
		var userid=<%=session.getAttribute("userId")%>;
		if(userid != "2799")
		{
			return false;
		}
		document.getElementById('id').value = id;
		temp = verId;
		var tdid= window.event.srcElement;//获取该td表格对象
		var tdtxt = tdid.innerText;//获取原先的td值
		var str = "<div id='tdcag'><input type='text' style='width:50px;' onkeydown='return changePatchQuestiontesterStage(event,"+id+")' onblur='ChangePatchQuestiontesterText("+id+");' id='txtId' value='"+tdtxt+"'>";
		str+="<input type='hidden' id='tdInitValue' value='"+tdtxt+"'>";
		str+="</div>";//拼接td中要输入的新的值
		tdid.innerHTML=str;//td对象输入新值
		
		document.getElementById("txtId").focus();
		var ctr=document.getElementById("txtId").createTextRange();
		ctr.collapse(false);
		ctr.select();
	}

编辑状态 失去焦点 保存：
function ChangePatchQuestiontesterText(id){
	if(iskeydown == 1){
		return;
	}
	var verId = temp+"";
	document.getElementById('id').value = id;
	var txtld=document.getElementById("txtId").value;//新值
	var tdid=document.getElementById("tdcag").parentNode;//获得div的上一级  得到td对象
	var tdtxt = document.getElementById("tdInitValue").value;//之前的值
	if(txtld==tdtxt){
		tdid.innerText=tdtxt;//如果前后值一致  没有改变  直接赋值之前的值  返回
		return;
	}
	
	if(confirm("确定要修改吗？")){//前后不一致 进到后台保存新值
		tdid.innerText=txtld;
		//var patchQuestiontesterStage = encodeURI(encodeURI(txtld));
		var patchQuestiontesterStage = txtld;
		document.forms[0].action = "<%=request.getContextPath()%>/patch/editRequirementSave2.action?getWebPatchQuestiontester="+patchQuestiontesterStage+"&verId="+verId+"&type=patchQuestiontester";
		document.forms[0].submit();
		return;
	}else{
		tdid.innerText=tdtxt;
		return;
	}
}



十六，get请求  传参  避免中文乱码
1，encodeURI(encodeURI(xxx));
URLDecoder.decode(xxx, "UTF-8");
2,new String(getWebPatchQuestiontester.getBytes("ISO8859_1"), "GBK");

十七，新窗口 数据 传到打开之前的窗口
两个页面引入相同的js
js中写方法：
function getDevice(devicemodel) {
document.getElementById("involvedBoard").value = devicemodel;
}

function selectT() {
var devicemodelList = document.getElementsByName("devicemodels");
window.opener.getDevice(devicemodelList[0].value);
window.close();
}

if(window.opener.document.getElementById("tblVersion")){
var tempRows = window.opener.document.getElementById("tblVersion").rows;

十七，java调用外部python文件，并调用里面的方法
1，导入jar包  jython
@SuppressWarnings("resource")
PythonInterpreter interpreter = new PythonInterpreter(); 
interpreter.execfile("D:\\py\\auth.py");
PyFunction func = (PyFunction)interpreter.get("w3auth",PyFunction.class);  

String username =userVo.getUserName();
String password =userVo.getUserPassword() ;
PyObject pyobj = func.__call__(new PyString(username), new PyString(password)); 

十八，httpclient
1，导入httpclient jar包

带参数的访问：— — — —
//创建一个httpclient对象
CloseableHttpClient httpClient = HttpClients.createDefault();
//创建一个uri对象
URIBuilder uriBuilder = new URIBuilder("https://login.huawei.com/login/login.do");
uriBuilder.addParameter("uid",userVo.getUserName());
uriBuilder.addParameter("password",userVo.getUserPassword());
uriBuilder.addParameter("verifyCode","2345");
uriBuilder.addParameter("actionFlag","loginAuthenticate");
uriBuilder.addParameter("loginMethod","login");
HttpGet get = new HttpGet(uriBuilder.build());
//执行请求
CloseableHttpResponse response =httpClient.execute(get);
HttpEntity entity =response.getEntity();
String string = EntityUtils.toString(entity,"utf-8");
//关闭httpclient
response.close();
httpClient.close();


十九，LDAP账号验证
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.naming.ldap.InitialLdapContext;
import javax.naming.ldap.LdapContext;

public class Test2
{
    private static final String INITCTX = "com.sun.jndi.ldap.LdapCtxFactory";
    private static final String SIMPLE = "simple";
    private static final String TLS = "tls";
    private static final String[] RETURN_ATTRIBUTES = new String[]{"samaccountname", "extensionattribute1"};

    public class AcountInfo{
    
    	public AcountInfo(String str1, String str2)
        {
            this.str1 = str1;
            this.str2 = str2;
        }

        public String str1;

        public String str2;

        public String getUsername()
        {
            return str1 + ":" + str2;
        }
    }
    
    private String ldapServiceAddress = "ldap://ldap-ad-gslb.huawei.com:389";
    
    public AcountInfo authenticate(String userName, String passwordStr){
        LdapContext lCtx = null;
        try
        {
            lCtx = new InitialLdapContext(getEnv(userName, passwordStr), null);

            SearchControls searchCtls = new SearchControls();
            searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);
            // 这里如果不设置该属性，默认返回所有属性
            searchCtls.setReturningAttributes(RETURN_ATTRIBUTES);

            String baseDn = "DC=china,DC=huawei,DC=com";
            String searchFilter = "(&(objectClass=user)(|(sn=" + userName
                    + ")(sAMAccountName=" + userName + ")))";

            // 查询用户
            NamingEnumeration<SearchResult> namingEnum = lCtx.search(baseDn,
                    searchFilter, searchCtls);

            List<AcountInfo> lstLdapUser = getUsersFromResults(namingEnum);
            if (lstLdapUser.size() == 1)
            {
                return lstLdapUser.get(0);
            }
        }
        catch (NamingException e)
        {
            System.out.println("auth failed:" + e);
        }
        finally
        {
            if (lCtx != null)
            {
                try
                {
                    lCtx.close();
                }
                catch (NamingException e)
                {
                    System.out.println("close failed:" + e);
                }
            }
        }
        return null;
    }

    /**
     * 获取UserInfo对象列表
     * 
     * @param results
     * @return List<UserInfo>
     * @throws NamingException
     */
    private List<AcountInfo> getUsersFromResults(
            NamingEnumeration<SearchResult> results) throws NamingException
    {
        List<AcountInfo> userList = new ArrayList<AcountInfo>();
        while (results != null && results.hasMoreElements())
        {
            SearchResult sr = results.next();
            Attributes attrs = sr.getAttributes();
            userList.add(attr2User(attrs));
        }
        return userList;
    }

    /**
     * 将Attributes里面的数据转换到UserInfo对象里面
     * 
     * @param attrs
     * @return UserInfo
     * @throws NamingException
     */
    private AcountInfo attr2User(Attributes attrs) throws NamingException
    {
        AcountInfo user = new AcountInfo(
                valueOfAttribute(attrs, RETURN_ATTRIBUTES[0]),
                valueOfAttribute(attrs, RETURN_ATTRIBUTES[1]));
        return user;
    }

    /**
     * 基于key获取value
     * 
     * @param attrs
     * @param key
     * @return String
     * @throws NamingException
     */
    private static String valueOfAttribute(Attributes attrs, String key)
            throws NamingException
    {
        Attribute attr = attrs.get(key);
        return attr != null ? (String) attr.get() : "";
    }

    /**
     * 组装InitialLdapContext所需的环境参数
     * 
     * @param userName
     * @param password
     * @return env
     */
    private Hashtable<Object, Object> getEnv(String userName, String password)
    {
        Hashtable<Object, Object> env = new Hashtable<Object, Object>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, INITCTX);
        env.put(Context.PROVIDER_URL, ldapServiceAddress);
        env.put(Context.SECURITY_AUTHENTICATION, SIMPLE);
        env.put(Context.SECURITY_PRINCIPAL, "CHINA\\" + userName);
        env.put(Context.SECURITY_CREDENTIALS, password);
        env.put(Context.SECURITY_PROTOCOL, TLS);
        return env;
    }
}


20,判断单选按钮是否选中 选中的给他赋值value
if(document.getElementsByName("issafeName")[0].checked == true){
	document.getElementById("issafe").value = "0";
}else if(document.getElementsByName("issafeName")[1].checked == true){
	document.getElementById("issafe").value = "1";
}



<s:set name="issafeName" value="issafe"></s:set>
<s:if test="#issafeName==0">            
<span class="STYLE4"><input type="radio" name="issafeName" checked="true"/><s:text name="YES"/><!-- 是 --></span>
<span class="STYLE4"><input type="radio" name="issafeName" /><s:text name="NO"/><!-- 否1 --></span>
</s:if>
<s:else>                  
<span class="STYLE4"><input type="radio" name="issafeName" /><s:text name="YES"/><!-- 是 --></span>
<span class="STYLE4"><input type="radio" name="issafeName" checked="true" /><s:text name="NO"/><!-- 否1 --></span>
</s:else>


21，js提取字符串中汉字  去除汉字
 //js只提取汉字  
function GetChinese(strValue) {  
    if(strValue!= null && strValue!= ""){  
        var reg = /[\u4e00-\u9fa5]/g;   
        return strValue.match(reg).join("");  
    }  
    else  
        return "";  
}  
 //js去掉汉字  
function RemoveChinese(strValue) {  
    if(strValue!= null && strValue != ""){  
        var reg = /[\u4e00-\u9fa5]/g;   
       return strValue.replace(reg, "");   
    }  
    else  
        return "";  
} 



22，jsp页面，由备份的下拉选框数据，恢复原始下拉选框下拉列表数据
备份的下拉选框数据：
<td style="display:none">
	<s:select size="1" class="putValue10" id="budingMaker_bak" name="budingMaker_bak" headerKey="" headerValue="--请选择--" list="budingMakerList" listKey="name" listValue="name" style='height:24px;width: 95px;' ></s:select>
</td>  
恢复原始下拉选框下拉列表数据：
var budingMaker = document.getElementById("budingMaker");
budingMaker.options.length = 0;
	var budingMakerBak = document.getElementById("budingMaker_bak");
	for(var i = 0; i < budingMakerBak.options.length; i++) {
			var tempOption = document.createElement("option");
			tempOption.text = budingMakerBak.options[i].text;    
			tempOption.value = budingMakerBak.options[i].value;   
			budingMaker.add(tempOption);
	}


23，jsp页面得到struts值栈值  赋值  前提是由action转发携带值栈值而来
<%
String c1 = request.getAttribute("xxx").toString();
%>

<%=c1%>

24，PLSQL Developer连接远程oracle配置
https://blog.csdn.net/dorothy1224/article/details/56282706

25，















		
		
		
		


$("#edit_customer_form").serialize()   前端序列化  中文转码

some:
spring容器：contextConfigLocation

<c:forEach items="${itemList }" var="item" varStatus="stu">  //varStatus  循环次数  ${stu.index}

返回数据
reuqest.setAttribute(arg0, arg1);
制定页面
reuqest.getRequestDispatcher("").forward(reuqest, response);   //dispather后面要写页面的全路径名，比如：/web-inf/...

请求转发：url不发生改变；request域中数据可以带过去；return "forward：xxx.action";
重定向：发生改变，request域中数据不能带过去;return "redirect：xxx.action";【springmvc  用model替代request域，数据都能带过去】


相对路径：不以/开头，为相对路径；
绝对路径：以/开头。

异步请求时，requestbody  responsebody 能将java对象和json串互相转换。post，get  区别。<url-pattern>/*</url-pattern> ；  /  拦截所有，但不包括.jsp   /*  拦截所有，包括.jsp；

5种创建对象得方式：
使用New关键字	是
使用Class类的newInstance	是
使用Constructor类的newInstance方法	是
使用clone方法	否
使用反序列化得方法	否
newInstance方法就是大家所说的反射。事实上Class的newInstance方法内部调用Constructor的newInstance方法。这也是众多框架，如Spring、Hibernate、Struts等使用后者的原因。

《Java编程思想》

一般在多表上创建外键约束。
alter table xxx add foreign key(id) references xxx(id);

多表之间的联合查询：
笛卡尔积：多表无条件的联合查询。
内连接：
外连接：左  右外连接
子查询：

分页
powerdesigner  er图  建数据库  DBA
逻辑外键
数据库连接池：dbcp，druid

arraylist数组
linkedlist双向循环列表
set集合 无需 不允许重复


队列 add
值栈 push



create user scott identified by 1234;
grant connect,resource,dba to scott;

onkeydown="onEnter('deliverperson',event)"
onkeydown="onEnter1('modifier',event)"

远程ip：10.171.149.152
oracle 密码：1234Qwer
w00215231
GBMu6!4v

ajax
dwr
iframe
jquery ui


w00284213   123
王海： w00215231    1

常用：
<link rel="stylesheet" href="a.css" type="text/css" />
<script type="text/javascript" src="<%=request.getContextPath()%>/js/Calendar.js"></script>
$("#div").removeAttr("style"); 
$("#div2").removeClass("abc");
$('#xxx').html("");
document.getElementById("xx").innerHTML = 
$("input[type='checkbox']").attr('value')
$("input[type='checkbox']").is(':checked')
window.location = "<%=request.getContextPath()%>/xxx.jsp";
window.open("<%=request.getContextPath()%>/xxx.jsp","_blank");

File f=new File("D:\\upexcel");
if (!f.exists()) {
f.mkdir();
}

var tbl = window.opener.document.getElementById("tblVersion");
str = str.substr(0, str.indexOf('_'));


输入命令：netstat -ano，列出所有端口的情况。在列表中我们观察被占用的端口，比如是49157，首先找到它。
查看被占用端口对应的PID，输入命令：netstat -aon|findstr "49157"，回车，记下最后一位数字，即PID,这里是2720
继续输入tasklist|findstr "2720"，回车，查看是哪个进程或者程序占用了2720端口，结果是：svchost.exe
或者是我们打开任务管理器，切换到进程选项卡，在PID一列查看2720对应的进程是谁，如果看不到PID这一列,如下图：
则我们点击查看--->选择列，将PID(进程标示符)前面的勾打上，点击确定。
这样我们就看到了PID这一列标识，看一下2720对应的进程是谁，如果没有，我们把下面的显示所有用户的进程前面的勾打上，就可以看到了，映像名称是svchost.exe，描述是，Windows的主进程,与上面命令查看的完全一致。
结束该进程：在任务管理器中选中该进程点击”结束进程“按钮，或者是在cmd的命令窗口中输入：taskkill /f /t /im Tencentdl.exe。


BOM:
window
location
history

DOM
事件+函数
页面广告：定时器

jquery 2.0往上版本  不支持ie678  要用1.几版本
Hbuilder编辑前端  有提示
jquery对象 $ .val()  dom对象 .value

restful  传递json数据
socket

maven  module  聚合工程  继承parent  平级的工程也能继承

svn服务端 客户端  
visualsvn 
eclipse svn
subversion  tortoisesvn 


select count(c.aguid) mibTotal,
count(c.mguid) mibCoverage,
c.module 
from (select a.module, max(a.guid) aguid, max(m.guid) mguid 
from t_ens_mib_base a 
LEFT JOIN t_ens_mib_match m 
ON (m.fk_mib = a.guid) 
where 1 = 1 and a.pdu='LSW' group by a.PDU,
a.guid,
a.enname,
a.module,
a.VERSION,
a.PRODUCT) c 
group by c.module

使用group by 时，有一个规则需要遵守，即出现在select列表中的字段，如果没有在组函数中，那么必须出现在group by 子句中。（select中的字段不可以单独出现，必须出现在group语句中或者在组函数中。）


pieData: {
	datas: [
		{
			value: 10,
			name: "覆盖"
		},
		{
			value: 100,
			name: "未覆盖"
		}
	],
	legend: ["覆盖", "未覆盖"]
}

给以上value赋值：
//this.pieData.datas[0].value=mibPieDataTmp.mibCoverage;
//this.pieData.datas[1].value=mibPieDataTmp.nonCoverage;


SELECT count(*)FROM (select 'x' from t_ens_mib_base a, t_ens_mib_match m where m.fk_mib = a.guid and a.pdu='LSW' group by a.PDU,a.guid,a.module,a.enname,a.VERSION,a.PRODUCT)



NVL函数是一个空值转换函数
NVL（表达式1，表达式2）
如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。该函数的目的是把一个空值（null）转换成一个实际的值。其表达式的值可以是数字型、字符型和日期型。但是表达式1和表达式2的数据类型必须为同一个类型。
对数字型： NVL（ comm,0);
对字符型 NVL( TO_CHAR(comm), 'No Commission')
对日期型 NVL（hiredate,' 31-DEC-99')


查询基线表中，分模块，查询该模块中，基线匹配情况sql  匹配数与总体基线数——
select count(c.aguid) mibTotal,count(c.mguid) mibCoverage,c.module from (

select a.module, max(a.guid) aguid, max(m.guid) mguid from t_ens_mib_base a LEFT JOIN t_ens_mib_match m ON (m.fk_mib = a.guid) where 1 = 1 and a.pdu='LSW' group by a.PDU,a.guid,a.enname,a.module,a.VERSION,a.PRODUCT

) c group by c.module




group by 多个字段
group by:
等于说 是按照你所 group by 的 东西进行分组 ，然后再对分组内的东西进行操作
group by 子句将查询结果按某一列或多列的值分组，值相等的为一组

select Cno，count(sno)
from sc
group by cno;
cno为课程号，sno为学号，sc表为选课表
该语句对查询结果按cno的值分组，所有具有相同cno的值元组为一组，然后对每一组，作用聚集函数count计算，以求得该组的学生人数

要取什么字段，必须要把它group分组，使其字段中，相同的归类到一起才行，否则select不到。
可以这样理解吧，一个group是为前面取字段服务的，在那个字段group下，取得那个字段的值。



select c.guid guid, 
			c.enname enname,
			c.cnname cnname ,
			c.node_oid oid, 
			c.times times, 
			c.module,
			c.node_name,
			c.max_access 
	  from (select nvl(SUM(m.mTime), 0) times,
					a.enname,
					NVL(TO_CHAR(a.cnname), '—') cnname,
					a.node_oid,
a.guid,
max(a.module) module,
a.node_name,
a.max_access 
		  from t_ens_mib_base a
			 LEFT JOIN t_ens_mib_match m
			  ON (m.fk_mib = a.guid)
			  where 1=1 and a.pdu='LSW'
		  and a.module='ENTITY-MIB'
		  group by a.guid, 
						a.module, 
						a.enname,
						a.cnname, 
						a.node_oid, 
						a.node_name,
						a.max_access) c order by c.times desc nulls last


vue 项目调试方法——
webpack dev config js
devtool: '#source-map'替换成
devtool: '#cheap-module-eval-source-map'
设置好之后，在vue项目调试的时候，代码里面标注debugger的时候就能看到对应的代码了，非常方便。






























































































































